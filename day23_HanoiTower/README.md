# 하노이의 탑 (Hanoi Tower)

## 문제 개요
세 개의 기둥과 N개의 원판이 있을 때, 모든 원판을 규칙에 맞게 옮기는 최소 이동 횟수와 이동 순서를 구하는 문제다.

### 규칙
1. 한 번에 하나의 원판만 이동할 수 있다.
2. 큰 원판은 작은 원판 위에 올릴 수 없다.
3. 원판은 항상 맨 위에서만 이동할 수 있다.

---

## 점화식 도출 과정
원판이 `N`개 있을 때, 이동 순서는 항상 다음과 같은 패턴으로 반복된다.
1. **N-1개의 원판**을 시작 기둥에서 보조 기둥으로 이동
2. **가장 큰 원판**을 시작 기둥에서 목표 기둥으로 이동
3. **N-1개의 원판**을 보조 기둥에서 목표 기둥으로 이동

이를 식으로 나타내면:
f(N) = f(N-1) + 1 + f(N-1)
즉, N개의 원판을 옮기기 위해서는 `N-1`개를 두 번 옮기고, 가장 큰 원판을 한 번 옮기는 과정이 필요하다.

---

## 코드

```python
import sys
input = sys.stdin.readline
N = input()

# 점화식 f(N-1) + 1 f(N-1) 패턴이 반복됨.
def hanoi_cnt(N):
    if N == 1:
        return 1
    return hanoi_cnt(N-1) + 1 + hanoi_cnt(N-1)

# f(x) = 1일 경우 a -> c로 원판 이동함
# f(x) = 2일 경우 a->b a->c b->c로 원판 이동함   
def hanoi(N, first, second, third):
    if N == 1:
        print(first, third) 
        return 1
    hanoi(N-1, first, third, second)
    print(first, third)
    hanoi(N-1, second, first, third)

print(hanoi_cnt(int(N)))
hanoi(int(N), 1,2,3)
```
## 호출 트리 (N=3)
~~~
hanoi(3, 1, 2, 3) # N,1,2,3 → 1,2,3은 A,B,C라고 생각하면 편함
│
├─ hanoi(2, 1, 3, 2)
│   ├─ hanoi(1, 1, 2, 3)  → print(1, 3)
│   ├─ print(1, 2)
│   └─ hanoi(1, 3, 1, 2)  → print(3, 2)
│
├─ print(1, 3)
│
└─ hanoi(2, 2, 1, 3)
    ├─ hanoi(1, 2, 3, 1)  → print(2, 1)
    ├─ print(2, 3)
    └─ hanoi(1, 1, 2, 3)  → print(1, 3)
~~~

## 나의 접근 방식
먼저 최소 이동 횟수를 계산하는 `hanoi_cnt()` 함수를 구현하여 점화식을 그대로 코드에 반영하였다.  

이후 실제 이동 경로를 출력하는 `hanoi()` 함수에서는 매개변수 `first`, `second`, `third` 순서를 재귀 호출 시 변경해 주는 방식으로 구현하였다.  

이렇게 계산과 출력을 분리하니 디버깅이 훨씬 쉬웠다.  

호출 트리를 직접 그려보며 재귀 흐름을 이해한 것이 큰 도움이 되었다.  

---

## 회고
처음에는 하노이의탑 이동 과정이 머릿속에서 잘 그려지지 않아, 영상으로 전체 이동 과정을 3번 반복해서 보았다.  
그 과정을 보며 **`f(x-1) + 1 + f(x-1)` 구조가 전체 이동에서 계속 반복된다는 사실**을 눈으로 확인할 수 있었다.  

또한, 원판이 1개일 때 `a → c`로 이동하는 패턴이 **고정**이라는 점을 깨달았고, N이 커져도 이 고정된 1번 이동이 전체 흐름의 '중간축' 역할을 한다는 것을 알게 되었다.  

이후 재귀 호출에서 매개변수의 위치를 바꾸는 것이 곧 **보조 기둥과 목표 기둥을 바꾸는 동작**이라는 사실을 이해하니, 각 호출이 전체 과정에서 어떤 위치를 차지하는지 명확히 보였다.  

결과적으로, 단순히 공식을 외우는 것이 아니라,  
- 이동 패턴이 재귀적으로 중첩된다는 점  
- 가장 작은 단위 이동(1번 원판 이동)이 전체 구조의 반복 단위라는 점  
- 매개변수 위치 변경이 곧 이동 방향 변경이라는 점  
을 모두 체득할 수 있었다.  

변형 문제(기둥이 4개 이상, 일부 이동 제한 등)에도 확장 가능성이 높다고 판단하였다.  

이 문제를 통해 **"재귀 호출 → 분할정복 → 패턴 인식"** 흐름을 한 번에 익힐 수 있었다.  
