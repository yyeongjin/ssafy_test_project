# SWEA 4615 - 재미있는 오셀로 게임

## 1. 문제 개요
오셀로 게임판의 크기와 돌을 놓는 순서가 주어질 때, 모든 돌을 놓은 뒤의 흑돌과 백돌의 개수를 출력하는 문제다  
기본 규칙은 전통적인 오셀로와 동일하며, 돌을 놓으면 해당 방향으로 상대 돌을 자신의 색으로 뒤집는다  

---

## 2. 접근 과정

### 2.1 초기 접근 - 함수 없이 하드코딩
처음에는 함수를 사용하지 않고 모든 로직을 메인 루프에 작성하는 방식으로 시도했다  
이 방식은 방향 탐색(델타 이동)을 8방향에 대해 개별적으로 구현해야 하다 보니,  
중복되는 코드가 많아지고 버그가 발생했을 때 수정하기도 어려웠다  
또한 각 방향별로 뒤집기 로직을 따로 작성하다 보니 가독성도 급격히 떨어졌다  

**실패 원인**
- 8방향 반복 로직을 복붙하다 실수가 발생했다  
- 가독성이 떨어져 디버깅이 힘들었다  
- 코드 길이가 불필요하게 길어졌다  

---

### 2.2 함수 분리 & 델타 이동 적용
하드코딩의 한계를 느낀 후, **`Othello`**라는 함수를 정의하여  
돌을 놓는 행위와 해당 방향의 돌 뒤집기 로직을 한 곳에서 처리하도록 변경했다  

이를 위해 **델타 배열**(`wasd`)을 만들어 8방향을 한 번에 순회하도록 했다  
```python
wasd = [
    (1, 0), (-1, 0),  # 상하
    (1, 1), (1, -1),  # 대각선 하향
    (-1, 1), (0, -1), # 대각선 상향 + 좌
    (0, 1), (-1, -1)  # 우 + 대각선 상좌
]
```

이렇게 하니 중복이 줄고, 가독성이 확실히 좋아졌다  

---

## 2.3 시행착오 & 개선

### 좌표 혼동  
처음에 `lst[y][x]` 대신 `lst[x][y]`로 잘못 접근하는 실수를 여러 번 했다  
Python 리스트 인덱싱에서 `lst[행][열]` 순서를 지켜야 한다는 점을 다시 확인했다  

### 뒤집기 로직 조건 실수  
돌을 뒤집기 전에 상대 돌이 연속되어 있는지 확인하고,  
같은 색 돌을 만나면 뒤집기를 해야 하는데,  
초반에는 같은 색을 만나기 전에 break를 해버리는 버그가 있었다  

### 함수 밖 변수 참조  
`lst`를 함수 내부에서 조작했는데, 초기에 지역/전역 개념을 놓쳐 값이 반영되지 않는 문제가 있었다  
(Python에서 리스트는 참조 타입이라 직접 변경하면 적용됨을 다시 확인했다)  

---

## 3. 최종 코드
```python
T = int(input())
for tc in range(1, T+1):
    N, M = map(int, input().split())
    wasd = [(1,0), (-1,0), (1,1), (1,-1), (-1,1), (0,-1), (0,1), (-1,-1)]
    black_count = 0
    white_count = 0

    lst = [[0 for _ in range(N+1)] for _ in range(N+1)]
    lst[N//2][N//2] = 2
    lst[N//2][N//2+1] = 1
    lst[N//2+1][N//2] = 1
    lst[N//2+1][N//2+1] = 2

    def Othello(x_1, y_1, color_1):
        lst[y_1][x_1] = color_1
        for dy, dx in wasd:
            wasd_lst = []
            ny, nx = y_1 + dy, x_1 + dx
            while True:
                if 1 <= nx <= N and 1 <= ny <= N:
                    if lst[ny][nx] != color_1 and lst[ny][nx] != 0:
                        wasd_lst.append((ny, nx))
                        nx += dx
                        ny += dy
                    elif lst[ny][nx] == color_1:
                        for y_2, x_2 in wasd_lst:
                            lst[y_2][x_2] = color_1
                        break
                    else:
                        break
                else:
                    break

    for _ in range(1, M+1):
        x, y, color = map(int, input().split())
        Othello(x, y, color)

    for i in lst:
        for j in i:
            if j == 1:
                black_count += 1
            elif j == 2:
                white_count += 1

    print(f'#{tc} {black_count} {white_count}')
```

## 4. 회고
원래도 델타 배열을 사용했지만, 하드코딩 형태로 작성하다 보니 각 방향 처리 로직이 분리돼 있어서 수정과 디버깅이 번거로웠다  
함수로 분리한 이후에는 코드 흐름이 명확해지고, 디버깅이 훨씬 쉬워졌다  
중복 로직이 줄어들면서 코드 수정 시 영향 범위를 한눈에 파악할 수 있게 됐다  
돌의 색 저장과 초기화 과정도 간단해져서 불필요한 조건문이나 중복 코드가 줄었다  
결과적으로 유지보수성과 확장성이 크게 개선됐다  

---

## 5. 의도
최대한 직관적인 로직 구성: 8방향을 한 번에 순회하고, 뒤집을 좌표를 리스트에 모아 한 번에 처리했다  
가독성 개선: 함수 분리로 코드의 흐름을 한눈에 볼 수 있게 했다  
유연성 확보: N 크기나 방향 로직이 변경돼도 최소한의 수정만으로 대응 가능하게 했다  
