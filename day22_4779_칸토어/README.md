# 칸토어 집합 재귀 구현 및 회고

## 문제 개요

칸토어 집합은 선분을 3등분하여 가운데를 제거하고 양 끝을 재귀적으로 같은 방식으로 분할하는 구조이다. 이 문제에서는 정수 N을 입력받아 칸토어 집합을 문자열로 출력하는 재귀 함수를 구현해야 했다.

---

## 코드 설명

```python
def cantor(num):
    if num == 0:
        return "-"
    return cantor(num-1) + " " * (3**num // 3) + cantor(num-1)

import sys
while True:
    try:
        N = int(sys.stdin.readline())
        print(cantor(N))
    except:
        break
```

* `cantor(num)`은 num == 0이면 "-"를 반환
* 그렇지 않으면 f(n) = f(n-1) + 공백 + f(n-1) 형태로 재귀적으로 문자열을 생성
* 공백의 길이는 3\*\*num // 3, 즉 현재 전체 길이의 1/3이다

---

## 나의 접근 방식

초기에는 전체 문자열을 "-"로 채우고 가운데를 반복적으로 지우는 방식으로 생각했다. 즉, "채워놓고 지운다"는 탑다운적 사고였다.

하지만 이 문제는 바텀업 구조였다. 가장 작은 단위에서 시작하여 좌측 + 공백 + 우측 구조를 재귀적으로 확장하는 형태였다.

이해를 돕기 위해 각 단계를 예로 들자면:
~~~txt
* f(0) = "-"
* f(1) = "- -" (공백 1칸)
* f(2) = "- -   - -" (공백 3칸)
* f(3) = "- -   - -         - -   - -" (공백 9칸)
~~~
즉, 항상 기존 결과(f(n-1))를 좌우로 붙이고, 가운데에 정확히 그 길이만큼의 공백을 삽입하면 f(n)이 완성된다.

이 구조는 아래 수식으로 정리된다:

```
f(n) = f(n-1) + " " * (3**n // 3) + f(n-1)
```

그리고 이 결과는 항상 길이 3의 거듭제곱인 3^n이 된다.

---

## 나의 접근 방식

나는 처음에 칸토어 집합을 f(x) 함수로 봤다. 처음에는 전체를 "-"로 채우고 가운데를 지우는 방식(탑다운 제거 방식)이라고 착각했다. 하지만 문제를 풀면서 칸토어는 바텀업 방식으로 아래에서부터 덧붙여 올라가는 구조라는 것을 깨달았다.

즉,
~~~txt
* f(0) = "-" (길이 1 = 3^0)
* f(1) = f(0) + 공백(1) + f(0) = "- -" (길이 3 = 3^1)
* f(2) = f(1) + 공백(3) + f(1) = "- -   - -" (길이 9 = 3^2)
~~~
이런 식으로 각 단계에서 길이가 3배로 증가한다.

---

## 쉬운 예시로 이해하기

처음에는 칸토어 집합을 완전히 다 채워놓고 가운데를 지우는 방식으로 접근했다. 하지만 실제 구조는 바텀업 재귀 구조였고, 이걸 이해하고 나니 전체 길이의 규칙성과 공백 위치가 명확하게 보였다.

### 1일 경우
~~~txt
* f(1) = f(0) + 공백 + f(0)
* 공백 길이: 3^1 // 3 = 1
* 리턴: "- -"
~~~
### 2일 경우
~~~txt
* f(2) = f(1) + 공백 + f(1)
* f(1)은 "- -"니까,
* 공백 길이: 3^2 // 3 = 3
* 결과: "- -       - -"
* 즉, f(1) + 3^2 // 3 + f(1) = f(n-1) + 3^n // 3 + f(n-1)
~~~
여기서 중요한 건:

* 기존에 만든 "- -" 그대로 붙이고,
* 그 중간에 정확히 공백 길이만큼 빈 공간이 생기며,
* 그 뒤에 또 "- -"가 복붙됨.

즉, 이렇게 보임:

```
- -       - -
```

* 가운데 공백이 들어가면서 길이가 3배로 커지는 구조.
* f(x) + 공백 + f(x) 구조가 그대로 확장됨.

이 흐름을 이해하면서 처음에 가졌던 직관(전체 구조에서 공백만 반복적으로 지워진다)이 실제로는 "재귀적으로 복사되는 패턴에 의해 구성된다"는 걸 체감할 수 있었다.

---

## 회고

가장 큰 오해는 칸토어 집합을 "채우고 지우는 방식"으로 본 것이었다. 실제로는 "비우면서 채우는 구조"였고, 그걸 재귀로 표현하면서 f(x) + 공백 + f(x) 구조가 만들어졌다.

이번 경험을 통해

* 재귀 구조가 어떻게 문자열의 길이를 지배하는지
* 수학적 귀납과 프로그래밍 재귀의 관계
* 구조적 패턴을 이해하는 게 얼마나 중요한지

를 체감할 수 있었다.

추가로, 이를 일반화하면 다음과 같은 것도 가능하다는 걸 깨달았다:

```python
def cantor(num):
    if num == 0:
        return "-"
    return cantor(num-1) + " " * (5**num//5) + cantor(num-1) + " " * (5**num//5) + cantor(num-1)
```

이 구조는 5등분 기반의 칸토어로, 길이는 5의 n승이 된다.

재귀적으로 구조를 확장해 나가는 감각을 익히기에 아주 좋은 문제였다.
